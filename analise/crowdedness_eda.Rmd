---
title: "Análise de dados exploratória de lotação"
output: html_document
---

```{r, warning=FALSE, message=FALSE}
init.time <- Sys.time()
library(plyr)
library(tidyverse)
library(ggmap)
```

Importando os dados:

```{r, warning=FALSE, message=FALSE}
path = "/local/luiz/bigsea/pre-processed-data/training_data_1_month"

filenames <- list.files(path, pattern = "*.csv", full.names=TRUE)
list_of_dataframes <- lapply(filenames, read.csv)
rm(filenames)
busData <- rbind.fill(list_of_dataframes)
rm(list_of_dataframes)
```

```{r, warning=FALSE, message=FALSE}
busData <- busData %>% select(route, busStopIdOrig, numPassengers, probableNumPassengers, hourOrig, date, hourDest, weekDay, weekOfYear, shapeLatOrig, shapeLonOrig, duration, problem)
str(busData)
```

Podemos ver que existem 40 variáveis, onde temos:

* route                    : rota do ônibus
* tripNumOrig              : o número da viagem do ônibus na origem
* shapeId                  : o id do shape do ônibus
* shapeSequence            : o ponto do shape que a viagem está atualmente
* shapeLatOrig             : a latitude da origem do shape
* shapeLonOrig             : a longitude da origem do shape
* distanceTraveledShapeOrig: a distancia que o ônibus já viajou na origem.
* busCode                  : o código do ônibus
* gpsPointId               : o id do ponto do gps
* gpsLat                   : a latitude do ponto do gps
* gpsLon                   : a longitude do ponto do gps
* distanceToShapePoint     : a distância do gps para o ponto do shape casado
* timestampOrig            : o horário no ponto de origem
* busStopIdOrig            : a parada do ônibus no ponto de origem
* problem                  : o tipo de problema encontrado pelo BULMA que pode ser NO_PROBLEM, quando não houver problema, NO_SHAPE, quando nenhuma trip foi formada (gps sem shape na base de dados ou com pontos insuficientes para formar trip), TRIP_PROBLEM, quando não foi possível identificar ponto final/ponto inicial, OUTLIER_POINT, quando os pontos excederam o threshold de distância para o shape.
* numPassengers            : a quantidade de passageiros que subiu no ônibus em determinada parada
* date                     : a data da viagem
* busStopIdDest            : o ponto de ônibus do destino
* timestampDest            : o horário no ponto de destino
* tripNumDest              : o número da viagem do ônibus no destino
* shapeLatDest             : a latitude do ponto do shape destino
* shapeLonDest             : a longitude do ponto do shape destino
* distanceTraveledShapeDest: a distancia que o ônibus já viajou no destino
* acumPassengers           : número de passageiros acumulado durante a viagem
* probableNumPassengers    : número provável de passageiros durante a viagem, estimando a descida dos mesmos
* duration                 : a duração entre a parada origem e destino
* distance                 : a distancia entre a parada origem e destino
* hourOrig                 : a hora de origem
* hourDest                 : a hora de destino
* isRushOrig               : indicativo se está em horário de pico na origem
* isRushDest               : indicativo se está me horário de pico no destino
* periodOrig               : o período na origem (manhã, tarde, noite)
* periodDest               : o período no destino (manhã, tarde, noite)
* weekDay                  : o dia da semana
* weekOfYear               : a semana do ano
* dayOfMonth               : o dia do mês
* month                    : o mês
* isHoliday                : indicativo se está em mês de férias
* isWeekend                : indicativo se é final de semana
* isRegularDay             : indicativo se está entre a terça e quinta inclusive

Análises posssíveis:

2) um panorama das distâncias entre as paradas
3) um panorama do número de shapes por rota
4) um panorama do número de paradas por shape
5) um panorama do tamanho dos shapes
6) Relação entre lotação entre uma parada e outra e a distância entre essas paradas
7) panorama do periodo do dia e lotação da viagem entre duas paradas
8) Panorama entre o dia da semana e a lotação da viagem entre duas paradas

analises que queremos:

1) Relação entre a hora do dia e lotação de uma viagem entre duas paradas
2) Relação entre o dia da semana e a lotação de uma viagem entre duas paradas
3) Relação entre a área da cidade e a lotação de uma viagem entre duas paradas

Vejamos primeiramente qual a quantidade de paradas que cada rota tem:

```{r, warning=FALSE, message=FALSE}
gp.bus.data <- busData %>% distinct(route, busStopIdOrig) %>% group_by(route) %>% summarise(num.stops = n())

summary(gp.bus.data)
ggplot(gp.bus.data, aes("num.stops", num.stops)) + geom_boxplot()

rm(gp.bus.data)
gc()
```

Vemos que a mediana é de 66 paradas, o primeiro quartil sendo 43 e o terceiro sendo 98.75 paradas.

Vejamos agora a quantidade de pessoas que sobem por paradas nas diferentes rotas:

```{r, warning=FALSE, message=FALSE}
gp.bus.crowdedness <- busData %>% 
  group_by(route) %>% 
  summarise(
    max.entered.passengers = max(numPassengers, na.rm = TRUE),
    median.entered.passengers = median(numPassengers, na.rm = TRUE),
    median.crowdedness = median(probableNumPassengers)    
  )

ggplot(gp.bus.crowdedness, aes(x = "num.passengers", max.entered.passengers)) +
  geom_boxplot()

gp.bus.crowdedness %>% 
  arrange(max.entered.passengers) %>% 
  head(30)
```

Vemos que existem muitas rotas que não entram pessoas no ônibus. Com isso, vamos filtrar as rotas que não entram pessoas:

```{r}
gp.bus.crowdedness.positive.passengers <- gp.bus.crowdedness %>% 
  filter(max.entered.passengers > 0)

  ggplot(gp.bus.crowdedness.positive.passengers, aes(x = "num.passengers", max.entered.passengers)) +
    geom_boxplot()

rm(gp.bus.crowdedness)
gc()
```

Apesar de uma pequena diferença, vamos prosseguir na filtragem:

```{r}
bus.data.filt <- busData %>%
  filter(route %in% gp.bus.crowdedness.positive.passengers$route)

rm(gp.bus.crowdedness.positive.passengers)
rm(busData)
gc()
```

Agora iremos verificar a distribuição da quantidade de passageiros que subiram em um ônibus em uma parada, fornercida pelo BULMA.
```{r, warning=FALSE, message=FALSE}

ggplot(bus.data.filt, aes(numPassengers)) + 
  geom_histogram(bins = 100)

```

```{r , warning=FALSE, message=FALSE}
bus.data.filt2 <- bus.data.filt %>%
  filter(numPassengers<100)

ggplot(bus.data.filt2, aes(numPassengers)) + 
  geom_histogram(bins = 100)

rm(bus.data.filt2)
gc()
```

Vemos que existem muitas rotas em que a quantidade de passageiros que subiram no ônibus em determinada parada é próxima de zero.


## Hora do dia
Agora vamos plotar um gráfico de lotação de viagens entre paradas por horas do dia.
```{r, warning=FALSE, message=FALSE}
ggplot(bus.data.filt, aes(x = as.factor(hourOrig), y = probableNumPassengers, colour = problem)) +
  geom_jitter(aes(alpha = 0.5))
```

Podemos perceber que muitas viagens têm lotação baixa, mas também existem uma grande quantidade de quantidade de passageiros com valores consideráveis e outros que parecem ser outliers.

Vejamos outra visualização para que fique mais nítido:

```{r, warning=FALSE, message=FALSE}
ggplot(bus.data.filt, aes(x = as.factor(hourOrig), y = probableNumPassengers)) + 
  geom_boxplot()
```

Podemos ver que grande parte do tempo os ônibus permanecem vazios, ou com poucas pessoas. Talvez isso indique que as pessoas andem mais paradas dentro do ônibus do que o algoritmo de pre-processamento esta estimando. Em compensação existem valores muito altos, onde o maior chega a mais de 300, que é um erro gerado pela estimativa.

Vamos ver se o problema das viagens identificado pelo BULMA tem relação com a quantidade provável de passageiros:

```{r, warning=FALSE, message=FALSE}
ggplot(bus.data.filt, aes(x = as.factor(hourOrig), y = probableNumPassengers)) + 
  geom_boxplot() +
  facet_wrap(~problem)
```

Podemos verificar que a quantidade de passageiros dentro do ônibus continua pequena, mesmo separando os tipos de problema das viagens identificados pelo BULMA.

Vejamos a mediana da quantidade provável de passageiros por hora do dia:

```{r, warning=FALSE, message=FALSE}
summarised.dates <- bus.data.filt %>% group_by(date) %>%
  summarise(meanCrowdedness = mean(probableNumPassengers),
            medianCrowdedness = median(probableNumPassengers))

temp1 <- bus.data.filt %>% select(date, hourOrig, hourDest, probableNumPassengers)
temp1 <- left_join(temp1, summarised.dates, by = "date")
rm(summarised.dates)

temp1 <- temp1 %>% mutate(
  diffFromMedian = probableNumPassengers - medianCrowdedness
)

temp2 <- temp1 %>% group_by(hourOrig) %>%
  summarise(
   medianOfDiffs = median(diffFromMedian)
)
rm(temp1)

ggplot(temp2, aes(as.factor(hourOrig), medianOfDiffs)) +
  geom_bar(stat = "identity", fill = "#2f4c56", legend = FALSE) + 
  scale_y_continuous("Média das diferenças (em quantidade de passageiros)") +
  theme(axis.title.x = element_blank()) +
  labs(title = "Mediana das diferenças entre número de passageiros de viagens e a quantidade de passageiros mediana do dia")
rm(temp2)
gc()
```

Vemos que existe um pico logo no início da manhã sobre a quantidade de passageiros, o qual tem um retorno perto do meio dia e final da tarde.

##Dia da semana

Vejamos se a lotação é influenciada pelos dias da semana

```{r, warning=FALSE, message=FALSE}
bus.data.filt <- bus.data.filt %>% 
  mutate(
    weekDay = factor(weekDay, levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"))
  )

ggplot(bus.data.filt, aes(x = weekDay, y = probableNumPassengers)) +
  geom_boxplot()
```

Vemos que os dias não parecem influenciar a quantidade mediana de passageiros.

```{r, warning=FALSE, message=FALSE}
summarised.weeks <- bus.data.filt %>% group_by(weekOfYear) %>%
  summarise(medianWeek = median(probableNumPassengers))

temp3 <- bus.data.filt %>% select(weekOfYear, weekDay, probableNumPassengers)
temp3 <- left_join(temp3, summarised.weeks, by = "weekOfYear")
rm(summarised.weeks)

temp3 <- temp3 %>% mutate(
  diffFromMedian = probableNumPassengers - medianWeek
)

temp4 <- temp3 %>% group_by(weekDay) %>%
  summarise(
   medianOfDiffs = median(diffFromMedian)
)
rm(temp3)

temp4 %>% 
  mutate(weekDay = factor(weekDay, levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"))) %>% 
  arrange(weekDay) %>% 
  ggplot(aes(as.factor(weekDay), medianOfDiffs)) +
    geom_bar(stat = "identity", fill = "#2f4c56", legend = FALSE) + 
    scale_y_continuous("Média das diferenças (em número de passageiros)") +
    theme(axis.title.x = element_blank()) +
    labs(title = "Quanto (em média) a mediana da quantidade de passageiros de cada dia da \nsemana diferencia da mediana das quantidades de passageiros da semana")
rm(temp4)
gc()
```

Vemos que a segunda feira é o dia que mais se diferencia, tendo a menor quantidade de passageiros da semana.

##Área da cidade
```{r, warning=FALSE, message=FALSE}
m <- get_map("Curitiba",zoom=11,maptype="toner",source="stamen")

g <- ggmap(m)
rm(m)
gc()
```

Vamos fazer um grid com a latitude entre -25.67 e -25.33 e longitude entre -49.40 e -49.07.

```{r, warning=F, message=F}
lat.min <- -25.67
lat.max <- -25.32
lon.min <- -49.40
lon.max <- -49.07

lat.step <- (lat.max - lat.min) / 50
lon.step <- (lon.max - lon.min) / 50

bus.data.grid <- bus.data.filt %>% 
  mutate(
    lat.grid.index = floor((shapeLatOrig - lat.min) / lat.step),
    lon.grid.index = floor((shapeLonOrig - lon.min) / lon.step)
  )
```

Vejamos a quantidade de passageiros mediana em um mapa:

```{r, warning=F, message=F}
bus.data.grid <- bus.data.grid %>% 
  mutate(
    plotting.lat = lat.min + (lat.grid.index * lat.step + (lat.grid.index + 1) * lat.step) / 2,
    plotting.lon = lon.min + (lon.grid.index * lon.step + (lon.grid.index + 1) * lon.step) / 2
  )

summarised.grid <- bus.data.grid %>% 
  group_by(plotting.lat, plotting.lon) %>% 
  summarise(
    median.num.passengers = median(probableNumPassengers)
  )

g +
  geom_tile(aes(x = plotting.lon, y = plotting.lat, fill = median.num.passengers), data = summarised.grid, alpha = 0.5) + 
  viridis::scale_fill_viridis(direction = -1)
```

Podemos ver que realmente existem trechos da cidade que tem a duração maior.

Vamos atenuar os valores maiores para verificar a região que tem maior concentração de passageiros:

```{r, warning=FALSE, message=FALSE}
g +
  geom_tile(aes(x = plotting.lon, y = plotting.lat, fill = sqrt(median.num.passengers)), data = summarised.grid, alpha = 0.5) + 
  viridis::scale_fill_viridis(direction = -1)
summarised.grid <- NULL
```
 
Podemos ver que ao contrário da duração, os corredores da cidade tem ter valores menores de passageiros.

Vejamos o quanto que esses trechos se diferenciam da mediana durante a semana:

```{r, warning=F, message=F}
hour.median.num.passengers <- bus.data.filt %>% 
  group_by(hourOrig) %>% 
  summarise(
    median.num.passengers = median(probableNumPassengers)
  )

joined.grid <- left_join(bus.data.grid, hour.median.num.passengers, by = "hourOrig") %>% 
  mutate(diff.num.passengers = probableNumPassengers - median.num.passengers)

rm(hour.median.num.passengers)
rm(bus.data.grid)

hourly.summarised.joined.grid <- joined.grid %>% 
  group_by(plotting.lat, plotting.lon) %>% 
  summarise(
    median.diff.num.passengers = median(diff.num.passengers)
  )

rm(joined.grid)

min.median.diff.num.passengers <- min(hourly.summarised.joined.grid$median.diff.num.passengers)

hourly.summarised.joined.grid <- hourly.summarised.joined.grid %>% 
  mutate(
    positive.median.diff.num.passengers = median.diff.num.passengers + abs(min.median.diff.num.passengers)
  )

g +
  geom_tile(aes(x = plotting.lon, y = plotting.lat, fill = positive.median.diff.num.passengers), data = hourly.summarised.joined.grid, alpha = 0.5) + 
  viridis::scale_fill_viridis(direction = -1)
gc()
```

Podemos verificar que as periferias tem um número maior de passageiros e os mesmos corredores mencionados anteriormente tem duração inferior as demais regiões.

Como os corredores da cidade tem valores de duração alto e de lotação baixos, vejamos se existe uma correlação entre a duração e lotação:

```{r, warning=F, message=F}
ggplot(bus.data.filt, aes(x = duration, y = probableNumPassengers)) +
  geom_point() +
  geom_smooth(method = "lm")
```

Vamos filtrar os valores entre o 5 percentil e o 95 percentil:

```{r, warning=F, message=F}
duration.percentiles <- quantile(bus.data.filt$duration, c(.05, .95), na.rm = TRUE)
passengers.percentiles <- quantile(bus.data.filt$probableNumPassengers, c(.05, .95), na.rm = TRUE)

bus.data.filt <- bus.data.filt %>%
  filter(
    duration > duration.percentiles[1],
    duration < duration.percentiles[2],
    probableNumPassengers > passengers.percentiles[1],
    probableNumPassengers < passengers.percentiles[2]
  )

ggplot(bus.data.filt, aes(x = duration, y = probableNumPassengers)) +
  geom_point() +
  geom_smooth(method = "lm")

d2 <- bus.data.filt %>% 
  select(duration, probableNumPassengers) %>% 
  mutate(
    lg.duration = log(duration),
    lg.probableNumPassengers = log(probableNumPassengers)
    ) %>%
  filter(
    !is.nan(lg.duration) &
      !is.nan(lg.probableNumPassengers) &
      !is.na(lg.duration) & 
      !is.na(lg.probableNumPassengers) & 
      !is.infinite(lg.duration) & 
      !is.infinite(lg.probableNumPassengers)
    )
cor(d2$lg.duration, d2$lg.probableNumPassengers)

rm(d2)
rm(bus.data.filt)
gc()

```

Vemos que não existe correlação significativa entre a duração e a quantidade de passageiros.

```{r}
final.time <- Sys.time()
running.time <- as.character(final.time - init.time)
write.csv(running.time, "runningtime.csv", row.names = F)
```

